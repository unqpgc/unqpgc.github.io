<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="expires" content="0">
    <meta http-equiv="pragma" content="no-cache">
    <meta name="author" content="Pablo Barenbaum">
    <meta name="description" content="Parseo y Generación de Código, Licenciatura en Informática con Orientación en Desarrollo de Software, Universidad Nacional de Quilmes">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Oxygen" type="text/css" rel="stylesheet">
    <title>Parseo y Generación de Código</title>
  </head>
  <body>
    <h1 class="title">Parseo y generación de código</h1>
    <div id="menu">
      <p><a href="index.html">Principal</a></p><p><a href="programa-y-bibliografia.html">Programa y bibliografía</a></p><p><a href="instancias-de-evaluacion.html">Instancias de evaluación</a></p><p><a href="clases.html">Clases teóricas</a></p><p><a href="practicas.html">Prácticas</a></p>
    </div>
    <div id="content">
      <h1 id="programa">Programa</h1>
<ul>
<li><em>Estructura de un compilador</em>. Fases de un compilador, compilación vs. interpretación.</li>
<li><em>Análisis léxico</em>. Lenguajes regulares, expresiones regulares, autómatas finitos.</li>
<li><em>Análisis sintáctico</em>. Gramáticas independientes del contexto, árboles de sintaxis, parsers descendentes y ascendentes, generadores de parsers.</li>
<li><em>Interpretación</em>. Ejemplos de interpretación para lenguajes imperativos, funcionales, orientados a objetos.</li>
<li><em>Análisis semántico</em>. Tablas de símbolos, inferencia de tipos, unificación.</li>
<li><em>Generación de código intermedio</em>. Máquinas de pila, máquinas de registros, análisis y síntesis de atributos.</li>
<li><em>Análisis estático</em>. Grafos de flujo, análisis de flujo de datos local hacia adelante y hacia atrás.</li>
<li><em>Optimización</em>. Eliminación de código muerto, propagación de constantes, loop unrolling.</li>
<li><em>Soporte en tiempo de ejecución</em>. Representaciones tagged vs. tagless, registros de activación, garbage collection.</li>
<li><em>Generación de código</em>. Register allocation y spilling, selección de instrucciones.</li>
</ul>
<h1 id="bibliografía">Bibliografía</h1>
<h2 id="básica">Básica</h2>
<ul>
<li>Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman. <em>Compilers: Principles, Techniques, and Tools (2nd Edition)</em>. Addison Wesley, 2006.</li>
<li>Andrew W. Appel. <em>Modern Compiler Implementation in C</em>. Cambridge University Press, 1998.</li>
</ul>
<h2 id="complementaria">Complementaria</h2>
<h3 id="lenguajes-formales">Lenguajes formales</h3>
<ul>
<li>John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman. <em>Introduction to Automata Theory, Languages and Computation</em>.</li>
</ul>
<h3 id="compilación-de-lenguajes-funcionales-y-orientados-a-objetos">Compilación de lenguajes funcionales y orientados a objetos</h3>
<ul>
<li>Simon Peyton Jones. <em>The Implementation of Functional Programming Languages</em>. Prentice Hall, 1987.</li>
<li>Christian Queinnec. <em>LiSP in Small Pieces</em>.</li>
<li>Guy L. Steele. <em>RABBIT: A Compiler for SCHEME</em>.</li>
<li>Adele Goldberg, David Rodson. <em>Smalltalk-80: The Language and Its Implementation</em>.</li>
</ul>
<h3 id="sistemas-de-tipos">Sistemas de tipos</h3>
<p>Benjamin Pierce. <em>Types and Programming Languages</em>.</p>
<h3 id="manejo-automático-de-memoria">Manejo automático de memoria</h3>
<p>Richard Jones, Antony Hosking, Eliot Moss. <em>The Garbage Collection Handbook: The Art of Automatic Memory Management</em>.</p>

    </div>
  </body>
</html>
